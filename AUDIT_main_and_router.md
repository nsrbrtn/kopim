# Аудит: `lib/main.dart` и `lib/core/navigation/app_router.dart`

Дата: 2025-12-13

## Область анализа

- `lib/main.dart`: старт приложения, настройка timezone, инициализация Firebase, стартовый UI (loading/error), DevTools tracing для Riverpod.
- `lib/core/navigation/app_router.dart`: конфигурация `GoRouter`, редиректы по состояниям старта/авторизации, запуск синхронизации через `syncServiceProvider`.

## Краткое резюме

Основные риски связаны с:
- **необработанными async-ошибками** (могут приводить к крэшам/шуму в Crashlytics и неконсистентному UX),
- **ошибками работы с таймзоной** (критично для финансовых периодов, recurring и аналитики),
- **редирект-логикой роутера** (ломает deep link/URL и может уводить пользователя с целевого экрана),
- **утечкой внутренних ошибок в UI** (приватность/безопасность и UX).

## Что исправить (приоритеты)

Ниже список находок с текущим статусом: **ГОТОВО** или **НЕ СДЕЛАНО**.

### Blocker

#### 1) Unhandled async error при прогреве Firebase
- ✅ **ГОТОВО**
- Где: `lib/main.dart:33`
- Что исправить: `unawaited(container.read(firebaseInitializationProvider.future));` без обработки ошибки.
- На что влияет: потенциальный крэш/красный экран/непредсказуемые репорты ошибок, даже если дальше UI корректно показывает error-состояние.
- Приоритет: **Blocker**
- Как исправить (кратко):
  - Вариант A (проще): убрать прогрев и полагаться на `ref.watch(firebaseInitializationProvider)` в `MyApp`.
  - Вариант B: оставить прогрев, но обязательно обработать ошибку:
    - `unawaited(container.read(firebaseInitializationProvider.future).catchError((e, st) { FlutterError.reportError(...); }));`
- Возможные последствия, если не исправить:
  - ошибки инициализации будут “вылетать” как unhandled, усложняя диагностику и ухудшая стабильность старта.
 - Что сделано:
   - Прогрев Firebase оставлен, но добавлен `catchError` с `FlutterError.reportError`, чтобы исключение не было unhandled (`lib/main.dart:33-47`).
 - Как проверить:
   - Интеграционно: сломать Firebase init (невалидные options) и убедиться, что нет unhandled ошибок в консоли/Crashlytics, а UI показывает error-состояние.

#### 2) Deep link/URL могут ломаться из-за редиректа при auth loading
- ✅ **ГОТОВО**
- Где: `lib/core/navigation/app_router.dart:242-274`
- Что исправить: сохранение intended route и корректный редирект на `/home` во время `auth` loading, с возвратом на deep link после готовности.
- На что влияет: открытие deep link (web/desktop/mobile) на конкретный экран может всегда уводить на home, даже если пользователь авторизован.
- Приоритет: **Blocker**
- Как исправить (кратко):
  - Не редиректить по `user == null`, пока `_authState.isLoading`.
  - Либо завести “splash/startup gate” маршрут, который после готовности возвращает на `state.uri` (сохранение исходного intended route).
- Возможные последствия, если не исправить:
  - потеря deep link, плохая SEO/UX на web, рост ошибок “не туда попал” и падение конверсии входа.
- Что сделано:
  - Введено поле `_pendingLocation` и сохранение intended route через `_capturePendingLocation(state)` (`lib/core/navigation/app_router.dart:213-238`).
  - Теперь intended route сохраняется и при `_authState.isLoading`, и при `user == null` (auth завершён).
  - После успешного логина (`user != null`) при нахождении на `/home` выполняется одноразовый редирект обратно на `_pendingLocation` с очисткой.
- Как проверить:
  - `flutter test test/core/navigation/app_router_test.dart --reporter expanded`

### High

#### 3) Некорректное определение IANA timezone (эвристика по offset/abbr)
- ✅ **ГОТОВО**
- Где: `lib/main.dart:23-24` (через `lib/core/utils/timezone_utils.dart`)
- Что исправить: `resolveCurrentTimeZoneId()` подбирал зону по текущему offset и `timeZoneName` → возможны неверные совпадения.
- На что влияет: расчёт “дня/месяца”, аналитика по периодам, recurring/напоминания, дедлайны — всё, что зависит от локальной TZ.
- Приоритет: **High**
- Как исправить (кратко):
  - Получать IANA timezone ID с платформы (плагин/канал), эвристику оставить только fallback.
  - Кешировать выбранный timezone ID в persisted storage и обновлять при смене TZ.
- Возможные последствия, если не исправить:
  - “разъезд” дат и периодов, неверные агрегаты, recurring может срабатывать не в те дни (особенно DST/переезды).
 - Что сделано:
   - Добавлена зависимость `flutter_timezone` и асинхронный загрузчик `loadCurrentTimeZoneId()` с кешированием в `shared_preferences` (`lib/core/utils/timezone_utils.dart`).
   - На старте приложения timezone ID берётся через платформу и устанавливается в `tz.local` (`lib/main.dart:23-24`).
   - В критичных местах инициализации (например, уведомления и сохранение recurring) используется `await loadCurrentTimeZoneId()` для надёжности.
   - Эвристика оставлена только как fallback (если платформа вернула неизвестный/пустой ID).
 - Как проверить:
   - `flutter test test/core/utils/timezone_utils_test.dart --reporter expanded`
  - Ручной сценарий: сменить TZ устройства (особенно зоны с DST) → перезапустить приложение → убедиться, что `tz.local` соответствует системной TZ и recurring/периоды считаются корректно.

#### 4) Утечка внутренних ошибок в UI (сырой `'$error'`)
- ✅ **ГОТОВО**
- Где:
  - `lib/main.dart:196`
  - `lib/core/navigation/app_router.dart:317`
  - `lib/core/navigation/app_router.dart:335`
- Что исправить: прямой вывод `'$error'` пользователю.
- На что влияет: приватность (детали SDK/коды/внутренние сообщения), UX (“страшные” ошибки), поддержка (пользователь видит лишнее).
- Приоритет: **High**
- Как исправить (кратко):
  - В релизе показывать общее сообщение + “код ошибки/короткий идентификатор”.
  - Детали (stack/сообщение) — только в `kDebugMode` или через кнопку “Скопировать для поддержки”.
- Возможные последствия, если не исправить:
  - раскрытие внутренней информации, ухудшение доверия пользователя, потенциальные подсказки злоумышленнику о конфигурации/состоянии.
- Что сделано:
  - Заменён вывод `'$error'` на “человеческое” сообщение + вычисляемый короткий код ошибки; подробности показываются только в `kDebugMode`:
    - `lib/main.dart`
    - `lib/core/navigation/app_router.dart`

- Добавлены проверки в `test/core/navigation/app_router_test.dart`:
  - восстановление deep link после `auth` loading;
  - восстановление deep link после логина, когда `auth` завершён и `user == null`.
  - Примечание: в тестах не используется тип `Override` (в вашем стеке Riverpod 3.0.3 он не доступен как экспортируемый символ), поэтому параметр передаётся как `dynamic`.

### High

#### 3) Некорректное определение IANA timezone (эвристика по offset/abbr)
- Где: `lib/main.dart:23-24` (через `lib/core/utils/timezone_utils.dart`)
- Что исправить: `resolveCurrentTimeZoneId()` подбирает зону по текущему offset и `timeZoneName` → возможны неверные совпадения.
- На что влияет: расчёт “дня/месяца”, аналитика по периодам, recurring/напоминания, дедлайны — всё, что зависит от локальной TZ.
- Приоритет: **High**
- Как исправить (кратко):
  - Получать IANA timezone ID с платформы (плагин/канал), эвристику оставить только fallback.
  - Кешировать выбранный timezone ID в persisted storage и обновлять при смене TZ.
- Возможные последствия, если не исправить:
  - “разъезд” дат и периодов, неверные агрегаты, повторяющиеся операции могут срабатывать не в те дни, особенно на DST/переездах.

#### 4) Утечка внутренних ошибок в UI (Firebase/startup/auth)
- Где:
  - `lib/main.dart:196`
  - `lib/core/navigation/app_router.dart:317`
  - `lib/core/navigation/app_router.dart:335`
- Что исправить: прямой вывод `'$error'` пользователю.
- На что влияет: приватность (детали SDK/коды/внутренние сообщения), UX (“страшные” ошибки), поддержка (пользователь видит лишнее).
- Приоритет: **High**
- Как исправить (кратко):
  - В релизе показывать общее сообщение + “код ошибки/короткий идентификатор”.
  - Детали (stack/сообщение) — только в `kDebugMode` или через кнопку “Скопировать для поддержки”.
- Возможные последствия, если не исправить:
  - раскрытие внутренней информации, ухудшение доверия пользователя, потенциальные подсказки злоумышленнику о конфигурации/состоянии.

### Medium

#### 5) Потенциальный холодный старт: синхронная инициализация tzdata и поиск по всем локациям
- ✅ **ГОТОВО**
- Где:
  - `lib/main.dart:23-24`
  - `lib/core/utils/timezone_utils.dart` (скан `timeZoneDatabase.locations`)
- На что влияет: время первого кадра, jank на слабых устройствах/web.
- Приоритет: **Medium**
- Как исправить (кратко):
  - Ленивая инициализация timezone (когда реально нужна), либо кеширование результата, либо перенос в startup-этап с метрикой.
- Возможные последствия, если не исправить:
  - медленный старт → падение retention, ухудшение Core Web Vitals (на web).
- Что сделано:
  - Убран ранний вызов `tzdata.initializeTimeZones()` из `loadCurrentTimeZoneId()` для обычного пути (prefs/platform).
  - Тяжёлый fallback (инициализация tzdb + `_resolveHeuristically()` со сканом `timeZoneDatabase.locations`) выполняется только если:
    - нет значения в persisted storage и платформа не вернула timezone id, либо
    - при установке `tz.local` кандидаты оказались невалидными.
  - `initializeLocalTimeZone()` оборачивается в `TimelineTask` (debug/profile), чтобы видеть стоимость старта в DevTools Timeline.
- Как проверить:
  - `flutter test test/core/utils/timezone_utils_test.dart --reporter expanded`
  - Ручной сценарий: на устройстве/эмуляторе сменить TZ → перезапустить приложение → убедиться, что `tz.local` корректно установлен, а в обычном случае не выполняется долгий fallback-поиск.

#### 6) `SignInScreen` как route почти недостижим/лишний при текущей логике
- ✅ **ГОТОВО**
- Где:
  - route: `lib/core/navigation/app_router.dart:185-191`
  - показ sign-in: `lib/core/navigation/app_router.dart:281-283`
- На что влияет: путаница в навигации, сложнее поддерживать URL-поведение и редиректы.
- Приоритет: **Medium**
- Как исправить (кратко):
  - Либо сделать sign-in полноценным route и направлять туда редиректом,
  - либо убрать route и оставить только вложенный экран в shell (но тогда осторожно с web URL).
- Возможные последствия, если не исправить:
  - накопление “мертвых” маршрутов, неожиданные переходы при будущих изменениях auth.
- Что сделано:
  - `SignInScreen` сделан полноценным gate-route (`/sign-in`), а не вложенным экраном внутри `/home`:
    - при `user == null` после завершения auth-loading редирект идёт на `/sign-in`;
    - после логина возвращаемся на сохранённый deep link (`_pendingLocation`) или на `/home`.
  - В `_AppShell` убран embedded-показ `SignInScreen`, чтобы не было двух конкурирующих вариантов навигации.
- Как проверить:
  - Web: открыть `.../sign-in` напрямую → должен открыться экран входа.
  - Открыть deep link на произвольный экран при `auth` loading → после завершения auth остаёмся на целевом экране.

#### 7) Инициализация `SyncService` из UI + `unawaited(initialize())` внутри провайдера
- ✅ **ГОТОВО**
- Где:
  - вызов из UI: `lib/core/navigation/app_router.dart:278-280`
  - провайдер: `lib/core/di/injectors.dart:835`
- На что влияет: устойчивость синхронизации, обработка ошибок (async), предсказуемость жизненного цикла.
- Приоритет: **Medium**
- Как исправить (кратко):
  - Сделать `SyncService.initialize()` “safe” (catch+лог/Crashlytics) и/или вызывать `await` в контроллере старта (не из `build`).
  - В UI вместо `watch` ради сайд-эффекта — рассмотреть явный coordinator/provider, который управляет жизненным циклом.
- Возможные последствия, если не исправить:
  - редкие “фантомные” падения/ошибки синка, трудная диагностика проблем офлайн-очереди.
- Что сделано:
  - Убран сайд-эффект `ref.watch(syncServiceProvider)` из UI (`_AppShell`).
  - Убран `unawaited(service.initialize())` из `syncServiceProvider`, чтобы DI не запускал async-работу “сам по себе”.
  - Добавлен `syncCoordinatorProvider`, который слушает `authControllerProvider` и:
    - стартует `SyncService.initialize()` только для не-гостя;
    - останавливает синк при logout (через закрытие подписки на `syncServiceProvider`, позволяя autoDispose освободить ресурсы);
    - на Web не запускается (web-синк управляется `AppStartupController`).
- Как проверить:
  - Войти под не-гостем → синк должен стартовать без вызовов из UI.
  - Выйти → синк должен быть остановлен (подписки должны освобождаться).

#### 8) Provider tracing включён в profile; возможен лишний overhead
- ✅ **ГОТОВО**
- Где: `lib/main.dart:26-31`, `lib/main.dart:45-52`
- На что влияет: производительность в profile-режиме, объём timeline-данных.
- Приоритет: **Medium**
- Как исправить (кратко):
  - Управляемый флаг (например, `bool.fromEnvironment`) и выключено по умолчанию.
- Возможные последствия, если не исправить:
  - шум в профилировке и небольшой overhead в горячих сценариях.
- Что сделано:
  - Provider tracing выключен по умолчанию и включается только флагом `--dart-define=KOPIM_PROVIDER_TRACE=true`.
  - Включение возможно только в `debug/profile` (в release наблюдатель не подключается).
- Как проверить:
  - Запустить в profile с флагом: `flutter run --profile --dart-define=KOPIM_PROVIDER_TRACE=true`.
  - Открыть DevTools → Timeline и убедиться, что появляются события `provider:add`/`provider:update`.

## Рекомендуемая проверка (минимум)

- Интеграционный сценарий: “сломать Firebase init” → приложение должно стабильно показывать error-экран без unhandled ошибок.
- Интеграционный сценарий: открытие deep link на конкретный экран при `auth` в `loading` → после авторизации остаёмся на целевом экране.
- Тесты на таймзону (unit/integration): DST-переходы и зоны-двойники по offset; корректность расчёта “сегодня/месяц” для recurring/аналитики.
