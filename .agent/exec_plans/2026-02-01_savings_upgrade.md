# ExecPlan: Копилки — счета в карусели, проценты и план взносов

## Context and Orientation
- Цель: добавить связку копилки со счётом (для карусели и учёта), поддержку автоначисления процентов/капитализации и расчёт плана взносов к дате (неделя/месяц).
- Область кода: `lib/features/savings/**`, `lib/features/home/**`, `lib/features/accounts/**`, `lib/features/transactions/**`, `lib/core/data/database.dart`, `lib/core/services/auth_sync_service.dart`, `lib/features/**/data/sources/remote/`.
- Контекст/ограничения: offline-first, Drift миграции обязательны, автоген не править вручную, синхронизация через outbox/Firebase.
- Риски: рассинхрон между балансом счёта и прогрессом копилки (они не обязаны совпадать), миграции и обратная совместимость.

## Interfaces and Dependencies
- Внешние сервисы (Firebase/Analytics/Crashlytics): Firestore `saving_goals`, `accounts`, `transactions`, outbox.
- Локальные зависимости (Drift, codegen): Drift миграции, Freezed/Json, build_runner, l10n.
- Затрагиваемые API/модули: `SavingGoal`, `AccountEntity`, `AddContributionUseCase`, `SavingGoalRepository`, `homeAccountsProvider`, sync в `AuthSyncService`.

## Technical Design
### Модель данных
- `SavingGoal` (обновление): добавить поля
  - `linkedAccountId` (String?, nullable, для режима «без счёта»).
  - `targetDate` (DateTime?, nullable).
  - `interestRateAnnual` (double?, годовая ставка, 0.0..1.0).
  - `interestCompounding` (String enum: `monthly|weekly`).
  - `interestCapitalization` (bool).
  - `lastInterestAt` (DateTime?, последняя дата начисления).
- Таблица `savingGoals` — новые колонки с миграцией и дефолтами.
- `goalContributions` расширить:
  - добавить `kind` (String enum: `contribution|interest`) для аналитики/прогресса;
  - хранить `amount` всегда в minor units.

### Инварианты
- Копилка остаётся целью, баланс копилки (`currentAmount`) не обязан совпадать со счётом.
- Если `linkedAccountId == null`, пополнения не создают транзакцию, но пишутся в `goalContributions`.
- Если `linkedAccountId != null`, пополнения создают transfer-транзакцию: источник -> счёт копилки, и пишутся в `goalContributions`.
- Проценты учитываются в прогрессе только при `interestCapitalization == true` (увеличивают `currentAmount`).

### Потоки и use cases
- `AddContributionUseCase`:
  - при наличии `linkedAccountId` → создаёт transfer-транзакцию + `goalContributions(kind=contribution)`;
  - при отсутствии `linkedAccountId` → только `goalContributions` + обновление `currentAmount`.
- `ApplySavingGoalInterestUseCase`:
  - вычисляет, сколько периодов прошло с `lastInterestAt` до `now` (неделя/месяц);
  - для каждого периода начисляет проценты на базу (текущий `currentAmount`);
  - при капитализации:
    - если `linkedAccountId` есть → создаёт income-транзакцию на счёт копилки;
    - иначе увеличивает `currentAmount`;
  - пишет `goalContributions(kind=interest)` и обновляет `lastInterestAt`.
- `ComputeSavingPlanUseCase`:
  - считает требуемый взнос на неделю/месяц;
  - формулы:
    - без процентов: `PMT = (FV - PV) / k`;
    - с процентами и капитализацией (взнос в конце периода):
      `PMT = (FV - PV * (1 + i)^k) * i / ((1 + i)^k - 1)`,
      `i = r / n`, `n = 12` (месяц), `n = 52` (неделя).

### Автоначисление процентов (триггеры)
- UI-триггеры:
  - при открытии списка копилок (bulk).
  - при открытии деталей копилки (single).
- Фоновая джоба:
  - запускается при старте приложения и/или по расписанию (например, 1 раз в сутки);
  - выполняет `ApplySavingGoalInterestUseCase` для всех активных целей;
  - должна быть идемпотентной по `lastInterestAt`.

### Синхронизация и outbox
- Новые поля добавляются в payload `SavingGoal`.
- Для `goalContributions`:
  - либо синхронизировать как отдельную коллекцию (если уже есть логика),
  - либо хранить локально (если аналитика чисто локальная) — решение зафиксировать отдельно.

### UI/UX
- Форма копилки:
  - блок «Где храню» (выбор существующего счёта / создать накопительный / «без счёта»);
  - блок «Проценты» (ставка, период, капитализация);
  - блок «Целевая дата» + расчёт требуемого взноса на неделю/месяц.
- Детали копилки:
  - показывать связанный счёт, план взносов, историю начислений процентов.

## Plan of Work
- Спроектировать модель связки копилки со счётом и правила учёта баланса (баланс копилки может отличаться от счёта).
- Добавить поля/миграции/синхронизацию для копилок и вкладов/процентов.
- Перестроить поток пополнений и аналитики под новые сущности.
- Обновить UI: создание/редактирование копилки, карусель счетов, расчёт плана.

## Concrete Steps
1) Дизайн модели и инвариантов:
   - определить режимы хранения: `без счёта` (наличные/виртуально), `привязка к существующему`, `создать накопительный счёт`;
   - зафиксировать правило: баланс копилки не обязан совпадать с балансом счёта;
   - при привязке к счёту пополнения оформляются переводом, но прогресс копилки хранится отдельно;
   - определить поля копилки: `linkedAccountId`, `targetDate`, `interestRateAnnual`, `interestCompounding`, `interestCapitalization`, `lastInterestAt`.
2) Drift + модели + синхронизация:
   - расширить таблицу `savingGoals` (новые поля) и добавить миграцию;
   - обновить `SavingGoal` (Freezed/Json), `SavingGoalDao`, remote data source и outbox payload;
   - обновить `AuthSyncService` и связанные мапперы для новых полей.
3) Логика пополнений и аналитики:
   - `AddContributionUseCase` + репозиторий: если `linkedAccountId` задан → создавать transfer-транзакцию (source -> goal account) и записывать вклад;
   - расширить `goalContributions` (тип операции: взнос/проценты) или добавить новую таблицу, чтобы аналитика и прогресс не зависели от категорий/транзакций;
   - обновить `WatchSavingGoalAnalyticsUseCase` для расчёта из вкладов и процентов.
4) Проценты и капитализация:
   - добавить use case для автоначисления процентов на основе `lastInterestAt`, частоты и флага капитализации;
   - запускать автоначисление при открытии копилки/списка копилок и фоновым джобом;
   - проценты начисляются за каждый пропущенный период, взнос считается в конце периода;
   - при капитализации создавать доходную транзакцию на связанный счёт (или увеличивать `currentAmount` при режиме без счёта).
5) План взносов к дате:
   - добавить use case `ComputeSavingPlan` (без процентов и с процентами), поддержать частоту (месяц/неделя);
   - формула без процентов: `PMT = (FV - PV) / k`;
   - формула с процентами и капитализацией (взнос в конце периода):
     `PMT = (FV - PV * (1 + i)^k) * i / ((1 + i)^k - 1)`,
     где `i = r / n`, `n = 12` для месяца, `n = 52` для недели;
   - без капитализации проценты не увеличивают базу, использовать формулу без процентов;
   - UI: блок расчёта на экране копилки и/или в форме создания (показывать требуемую сумму на период).
6) UI и UX:
   - форма копилки: секции «Где храню» (обязательная связка со счётом, но есть режим «без счёта»), «Проценты», «Целевая дата»;
   - карточка/детали копилки: показывать связанный счёт, прогноз и план взносов;
   - карусель счетов: копилка показывается через связанный счёт (новый счёт автоматически появляется среди accounts).
7) Тесты и документация:
   - unit: расчёт процентов и плана; корректность перевода в addContribution;
   - integration: миграция + синхронизация; пополнение с привязкой к счёту;
   - обновить `docs/logic/feature_invariants.md` и `docs/logic/README.md`.

## Validation and Acceptance
- Команды проверки:
```bash
dart format --set-exit-if-changed .
flutter analyze
dart run build_runner build --delete-conflicting-outputs
flutter test --reporter expanded
```
- Acceptance criteria:
  - При создании копилки можно выбрать/создать накопительный счёт или режим «без счёта».
  - Связанный счёт отображается в карусели на главном экране.
  - Пополнения со счёта оформляются переводом и корректно влияют на баланс.
  - Проценты начисляются автоматически, капитализация учитывается.
  - Пользователь видит расчёт требуемого взноса на неделю/месяц до целевой даты.

## Idempotence and Recovery
- Что можно безопасно перезапускать: `dart format`, `flutter analyze`, `build_runner`.
- Как откатиться/восстановиться: откат миграции и удаление новых полей из `savingGoals` + удаление новых use cases.
- План rollback (для миграций): отдельная миграция, удаляющая новые колонки и пересчитывающая `currentAmount` из истории вкладов (если была синхронизация со счётом).

## Progress
- [ ] Шаг 1: Дизайн модели и инвариантов.
- [ ] Шаг 2: Drift/модели/синхронизация.
- [ ] Шаг 3: Логика пополнений и аналитики.
- [ ] Шаг 4: Проценты и капитализация.
- [ ] Шаг 5: План взносов к дате.
- [ ] Шаг 6: UI и UX.
- [ ] Шаг 7: Тесты и документация.

## Surprises & Discoveries
- ...

## Decision Log
- ...

## Outcomes & Retrospective
- Что сделано:
- Что бы улучшить в следующий раз:

## Definition of Done (чек-лист)

- `dart format --set-exit-if-changed .` без изменений.
- `flutter analyze` без ошибок.
- `dart run build_runner build --delete-conflicting-outputs` проходит.
- `flutter test --reporter expanded` проходит.
- Новая логика покрыта unit-тестами и хотя бы одним widget или integration тестом.
- Нет тяжелого CPU/I/O на UI isolate.
- Для изменений производительности — есть измерение до/после.

## Regression checklist

- Riverpod: минимизированы лишние rebuild, использованы `.select()`/листовые `ConsumerWidget`.
- Freezed: модели и состояния immutable, корректная генерация.
- Drift: миграции добавлены и протестированы, схема не правится вручную.
- Offline-first: запись сначала в локальную БД.
- Sync: конфликт-стратегия ясна, upsert идемпотентен.
- UI: списки оптимизированы (`itemExtent`/`prototypeItem`), форматтеры кэшированы.
- Ошибки/сеть: корректные offline/syncing/up-to-date состояния.

## Документация

- Любое изменение поведения → обновить `docs/`.
- Миграции/схемы → описать в `docs/logic/` (отдельный документ или обновление существующего).
- Изменения UX → `docs/components/` или `docs/logic/` с описанием поведения.
- Минимальный формат записи:
  - Что изменилось
  - Зачем
  - Как проверить
  - Breaking changes (если есть)
