# План улучшения кредитного флоу (Consumer Loan) - v3

Этот план решает проблемы учета долга, графика платежей и целостности данных, используя архитектуру **Payment Groups**.

> [!IMPORTANT]
> Принят подход **"Payment Group"** вместо "Parent/Child" транзакций для обеспечения гибкости (доп. комиссии, частичные оплаты) и корректности отображения.

---

## 1. База данных и Модель

### 1.1. Группа Платежа (`CreditPaymentGroup`)
Новая сущность, объединяющая физические транзакции в одно логическое событие оплаты.
*   `id`: UUID
*   `creditId`: Ссылка на кредит.
*   `sourceAccountId`: ID счета списания (кошелек). **Один на группу**.
*   `scheduleItemId`: Ссылка на элемент графика (nullable, если платеж вне графика).
*   `paidAt`: Дата платежа (фактическая).
*   `totalOutflow`: Общая сумма списания (для UI и проверки целостности).
*   `principalPaid`: Часть, ушедшая в тело долга.
*   `interestPaid`: Часть, ушедшая на проценты.
*   `feesPaid`: Часть, ушедшая на комиссии/штрафы (внеплановые).
*   `note`: Заметка пользователя.
*   `idempotencyKey`: Строка (nullable). Заполняется **только для автоплатежей**.
    *   Формат: `{creditId}_{periodKey}` или `{creditId}_{scheduleItemId}`.
    *   Для ручных платежей: `null`.

### 1.2. График Платежей (`CreditPaymentSchedule`)
Расширенная модель для реальных сценариев.
*   `id`: UUID
*   `creditId`: Ссылка на кредит.
*   `periodKey`: `YYYY-MM` (для удобной группировки/поиска).
*   `dueDate`: Дата планового платежа (LocalDate).
*   `status`: Enum (`planned`, `partially_paid`, `paid`, `skipped`).
    *   *Примечание:* Статус `overdue` не хранится, а вычисляется: `(today > dueDate && status != paid)`.
*   **План**:
    *   `principalAmount`: План по телу.
    *   `interestAmount`: План по процентам.
    *   `totalAmount`: Общая плановая сумма (`principal + interest`). Комиссии тут не учитываются.
*   **Факт**:
    *   `principalPaid`: Сколько реально погашено тела.
    *   `interestPaid`: Сколько реально погашено процентов.
    *   `paidAt`: Дата последнего платежа по этому пункту.

### 1.3. Обновление Кредита (`CreditEntity`)
*   `issueDate`: Дата выдачи.
*   `issueAmount`: Сумма выдачи.
*   `targetAccountId`: Счет зачисления (куда упали деньги).
*   `interestCategoryId`: ID категории для процентов (уникальная, `isSystem=true`).
*   `feesCategoryId`: ID категории для штрафов/комиссий (уникальная, `isSystem=true`).
*   `firstPaymentDate`: Дата первого платежа (для точного построения графика).

### 1.4. Транзакции (`TransactionEntity`)
*   `groupId`: Ссылка на `CreditPaymentGroup` (nullable).
*   Если `groupId` задан, транзакция считается частью группы.

---

## 2. Логика и Правила

### 2.1. Выдача кредита ("Zero Basis")
Чтобы не было "двойного долга":
1.  Кредитный счет создается с **Балансом 0**.
2.  Создается **Транзакция Перевода**: Кредитный Счет -> Счет Зачисления на сумму `issueAmount`.
    *   Баланс Кредита становится `-issueAmount`.
    *   Баланс Счета Зачисления увеличивается на `issueAmount`.

### 2.2. Генерация графика
*   Все суммы хранятся в `minor units` (копейки).
*   `firstPaymentDate` определяет старт графика.
*   Округление происходит **каждый месяц**.
*   **Последний платеж**: Корректируется, чтобы остаток долга стал 0.

### 2.3. Логика Оплаты (`MakePayment`)
1.  Пользователь вводит общую сумму и разбивку.
2.  **Ограничение**: В рамках одной группы платим только с одного `sourceAccountId`. Если нужно с разных — это два разных платежа.
3.  Создается `CreditPaymentGroup`.
    *   `totalOutflow = principalPaid + interestPaid + feesPaid`.
4.  Создаются транзакции (привязаны через `groupId`):
    *   **Тело**: Transfer (Кошелек -> Кредит).
    *   **Проценты**: Expense (Кошелек -> Категория Процентов).
    *   **Комиссии** (если есть): Expense (Кошелек -> Категория Штрафов).
5.  Обновляется `CreditPaymentSchedule` (если платим по графику):
    *   `principalPaid += paidBody`
    *   `interestPaid += paidInterest`
    *   *Примечание:* `feesPaid` не уменьшает плановый долг в графике.
    *   `status`: Пересчитывается на основе `principal` и `interest`.

### 2.4. Редактирование и Целостность
*   **Инвариант**: `Group.totalOutflow` == Сумма транзакций группы с исходного счета.
*   При редактировании пересчитываются: Транзакции -> Группа -> График.

---

## 3. UI / UX

### 3.1. Список транзакций (Feed)
*   `TransactionRepository` возвращает поток "Элементов Ленты" (`FeedItem`):
    *   `TransactionItem`: Обычная транзакция.
    *   `GroupedCreditPaymentItem`: Агрегат (`groupId`, `totalOutflow`, `sourceAccountId`, ...).
*   В списке у `GroupedCreditPaymentItem` рендерится одна строка "Погашение кредита" на сумму `totalOutflow`.

### 3.2. PayCreditSheet
*   Поля: Сумма, Досрочка (доп. тело), Комиссии.
*   Если открыт из графика: предзаполняет суммы.

### 3.3. Статус просрочки
*   Вычисляется на лету: `isOverdue = (now > dueDate) && (status != paid)`.

---

## План внедрения

### Этап 1: Фундамент (Schema)
1.  [x] Создать таблицы `payment_groups`, `payment_schedules`.
2.  [x] Миграция: Добавить поля в `accounts` (если нужно), `credits`, `transactions` (`group_id`).
3.  [x] Генератор Drift-кода.

### Этап 2: Core Logic
4.  [x] Утилита `AnnuityCalculator`.
5.  [x] `AddCreditUseCase`: создание счета, категорий (Interest + Fees), транзакции выдачи, рассчет графика.
6.  [x] `MakeCreditPaymentUseCase`: создание группы, транзакций (вкл. Fees), обновление графика.
7.  [ ] `UpdateCreditPaymentUseCase`: логика пересчета (реализован как заглушка).

### Этап 3: UI
8.  [x] Адаптация логки группировки: маппинг в `FeedItem`.
9.  [x] `TransactionList`: поддержка `GroupedCreditPaymentTile`.
10. [x] `PayCreditSheet`: реализация шторки оплаты.

### Этап 4: Аналитика и Полировка
11. [ ] Проверка отчетов и корректности категорий.
12. [ ] Тесты сценариев (частичная оплата, досрочное погашение).
