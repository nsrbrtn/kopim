# ExecPlan: Новый экран конкретного бюджета

## Context and Orientation
- Цель: добавить отдельный экран конкретного бюджета по новому дизайну и подключить переходы с главного экрана и списка бюджетов.
- Область кода: `lib/features/budgets/presentation/`, `lib/features/home/presentation/widgets/`, `lib/features/budgets/presentation/widgets/`, `lib/features/upcoming_payments/`.
- Контекст/ограничения: шрифты и цвета только из темы приложения; отступы между контейнерами на экране — 8px; без хардкода строк (только l10n); реальный источник данных; existing budget card без изменений.
- Риски: сложность фильтрации периодов и синхронизация нескольких потоков данных; нагрузка на UI при построении списков.

## Interfaces and Dependencies
- Внешние сервисы (Firebase/Analytics/Crashlytics): нет.
- Локальные зависимости (Drift, codegen): возможна генерация l10n при добавлении строк.
- Затрагиваемые API/модули: `BudgetProgress`, провайдеры бюджетов/транзакций/категорий, upcoming payments, навигация на `BudgetFormScreen`.

## Plan of Work
- Создать новый экран конкретного бюджета и UI-блоки по образцу.
- Подключить данные и фильтры «Месяц/Неделя».
- Реализовать раскрытие категорий и транзакций.
- Подключить список предстоящих платежей.
- Обновить навигацию с главного экрана и списка бюджетов.
- Добавить/обновить локализации и документацию.

## Concrete Steps
1) Создать новый экран `BudgetOverviewScreen` (название уточнить по архитектуре) с базовой разметкой секций: сводка, динамика, категории, предстоящие платежи.
2) Подключить источники данных: прогресс бюджета, транзакции, категории, upcoming payments; добавить фильтр «Месяц/Неделя» (неделя с понедельника, календарный месяц).
3) Реализовать динамику расходов (график) по выбранному периоду на реальных данных.
4) Категории: топ по расходам + раскрытие полного списка; по клику раскрывать список транзакций данной категории внутри экрана (по аналогии с аналитикой).
5) Предстоящие платежи: компактный горизонтальный список с данными upcoming payments; иконки категорий — текущие из приложения.
6) Навигация: новый экран открывается по клику на бюджет-виджет на главной и по клику на карточку бюджета в списке; AppBar «Редактировать» ведёт на `BudgetFormScreen`.
7) Добавить l10n строки; обновить `docs/` при изменениях поведения.

## Validation and Acceptance
- Команды проверки:
```bash
dart format --set-exit-if-changed .
flutter analyze
```
- Acceptance criteria:
  - Экран соответствует структуре образца и использует только тему приложения.
  - Отступы между контейнерами — 8px.
  - Переключатель «Месяц/Неделя» корректно фильтрует данные.
  - Клик по категории раскрывает транзакции этой категории.
  - Предстоящие платежи отображаются и фильтруются по выбранному периоду.
  - Переходы на экран доступны с главного экрана и списка бюджетов.

## Idempotence and Recovery
- Что можно безопасно перезапускать: `dart format`, `flutter analyze`, генерация l10n.
- Как откатиться/восстановиться: вернуть изменения в `lib/features/budgets/presentation/`, навигации и l10n.
- План rollback (для миграций): не требуется.

## Progress
- [ ] Шаг 1: Создать экран и секции.
- [ ] Шаг 2: Подключить данные и фильтры периодов.
- [ ] Шаг 3: Динамика расходов.
- [ ] Шаг 4: Категории + раскрытие транзакций.
- [ ] Шаг 5: Предстоящие платежи.
- [ ] Шаг 6: Навигация и l10n.
- [ ] Шаг 7: Документация и проверка.

## Surprises & Discoveries
- ...

## Decision Log
- Используем календарный месяц и неделю с понедельника.
- Предстоящие платежи берём из существующих источников без фильтра по бюджету.

## Outcomes & Retrospective
- Что сделано:
- Что бы улучшить в следующий раз:

## Definition of Done (чек-лист)
- `dart format --set-exit-if-changed .` без изменений.
- `flutter analyze` без ошибок.
- Новая логика покрыта unit-тестами и хотя бы одним widget или integration тестом.
- Нет тяжелого CPU/I/O на UI isolate.

## Regression checklist
- Riverpod: минимизированы лишние rebuild, использованы `.select()`/листовые `ConsumerWidget`.
- Freezed: модели и состояния immutable, корректная генерация.
- Drift: миграции не требуются.
- Offline-first: запись сначала в локальную БД.
- UI: списки оптимизированы (`itemExtent`/`prototypeItem`), форматтеры кэшированы.
- Ошибки/сеть: корректные offline/syncing/up-to-date состояния.

## Документация
- Любое изменение поведения → обновить `docs/`.
- Изменения UX → `docs/components/` или `docs/logic/` с описанием поведения.
- Минимальный формат записи:
  - Что изменилось
  - Зачем
  - Как проверить
  - Breaking changes (если есть)
