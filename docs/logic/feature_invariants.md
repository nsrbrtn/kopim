# Инварианты и правила по фичам

Этот документ фиксирует доменные инварианты и требования по ключевым фичам.

## Accounts (Счета)

Сущность: `Account { id, name, balance, openingBalance, balanceMinor, openingBalanceMinor, currency, currencyScale, type }` (Freezed).

Структура:

- Интерфейсы репозиториев — в `domain/`.
- Drift DAO — в `data/local/`.
- Firebase-адаптер — в `data/remote/`.

Инварианты:

- Каноничная сумма — `balanceMinor/openingBalanceMinor` + `currencyScale`.
- `balanceMinor = openingBalanceMinor + сумма транзакций` (с учётом переводов).
- `openingBalance` — стартовая база счёта; при редактировании баланса пересчитывается относительно истории транзакций.
- Баланс — derived‑значение; пересчёт выполняется централизованно в data‑слое и обязателен для всех путей записи транзакций (use cases, sync, import).
- Поля `balance/openingBalance` (double) обновляются как производные от minor для UI и legacy‑экспорта.

UI:

- Экран списка счетов: фиксированная высота строк; форматирование сумм и валют кэшируется; `.select()` на уровне листовых виджетов.
- Детальный экран счёта — не ломать инварианты баланса при ручных операциях.

## Transactions (Транзакции)

Сущность: `Transaction { id, accountId, categoryId, amount, amountMinor, amountScale, date, note, type }`.

Инварианты:

- Каноничная сумма — `amountMinor/amountScale`; `amount` (double) хранится как legacy/UI.
- `amount > 0` (знак задаётся через `type` или отдельное поле).
- `accountId` и `categoryId` ссылаются на существующие записи.
- Дебет/кредит-логика корректна (не переворачивать знаки без необходимости).
- `createdAt/updatedAt` хранятся в UTC; локализация выполняется только на уровне UI.
- Платёж по кредиту — обычная транзакция с `categoryId`, привязанной к кредиту; такие транзакции отображаются в списке транзакций кредитного счёта.

Операции в БД:

- Вставка/обновление транзакции — в рамках одной DB-транзакции:
  - обновляет запись транзакции;
  - пересчитывает `balanceMinor` соответствующего счёта единым helper‑ом data‑слоя;
  - синхронно обновляет `balance` (double) как производное;
  - при необходимости, обновляет агрегаты аналитики.

Дом/лента:

- Для домашнего фида и длинных списков:
  - `itemExtent` или `prototypeItem`;
  - листовые `ConsumerWidget` с `.select()`;
  - кэшированные `DateFormat` / `NumberFormat`.

## Categories (Категории)

Сущность: `Category { id, name, type, icon, color }`.

Инварианты:

- `type` может определять расход/доход/другое.

Иконки:

- Используется ограниченный, курируемый набор.
- Никаких runtime-поисков по тысячам иконок в горячих путях.

Связи:

- Категории привязаны к транзакциям и аналитике; удаление требует миграционной стратегии (soft delete, remap и т.п.).

## Credits (Кредиты)

Инварианты:

- Платёж по кредиту сдвигает дату следующего платежа на следующий месяц от даты платежа.
- При удалении платежа дата следующего платежа пересчитывается от предыдущего платежа; если платежей нет, используется текущая дата.

## Analytics (Аналитика)

Агрегации:

- Суммы по категориям/периодам/счетам, monthly cashflow, monthly balance и список транзакций по категориям — в Drift.
- Для overview возвращаются суммы по `category_id` и `root_category_id` (глубина категорий 2 уровня), top‑категории строятся по root, прямые траты корня попадают в `_direct:*`.
- Выполнение — вне UI isolate, результаты приходят как агрегированные DTO.
- Переводы в аналитике по счетам учитываются как отток/приток: исходный счёт −amount, целевой +amount; при выборе обоих счетов суммарный эффект 0.

UI:

- Графики/диаграммы работают с подготовленными DTO.
- Не делать сложные вычисления внутри `build`.
- Провайдеры используют узкие зависимости (`.select`) и `distinct`, чтобы не триггерить лишние rebuild.
- Окна дат выносятся в отдельные провайдеры (monthly cashflow/balance и аналитический range), чтобы стабилизировать перерасчёты.

Тесты:

- Юнит-тесты для агрегаций с edge-cases: нулевые периоды, без категорий, много валют.

## Auth / Profile (Профиль и вход)

Firebase:

- Инициализацию Firebase делать после первого кадра (не блокировать старт UI).

UI:

- Пока Firebase не готов — показывать скелетон/экран загрузки.

Синк:

- При входе — запуск логики синхронизации локальных данных с облаком.
- После LWW merge аккаунтов баланс пересчитывается из транзакций (minor‑units), `account.balance` — derived.

Performance:

- Firebase Performance — кастомные трейсы вокруг логики входа и первой загрузки данных.

## Budgets (Бюджеты)

Модель:

- Бюджеты по категориям или общие.
- Поля: лимит, период, привязка к категориям/счетам, статус.

Логика:

- Расчёт выполнения бюджета через запросы Drift (агрегации расходов по периодам/категориям/счетам).
- UI‑слой не перебирает все транзакции для расчёта прогресса.
- Инварианты: бюджет не уходит в неконсистентные состояния.

Тесты:

- Юнит-тесты для краевых случаев: пересечение периодов; изменения бюджета в середине периода.

## Recurring Transactions (Повторяющиеся транзакции)

Модель:

- RRULE-подобные поля (тип повторения, интервал, дата начала/конца).
- Флаг pause/resume.

Логика:

- Детерминированный расчёт следующего срабатывания.
- Генерация транзакции по расписанию не должна дублировать запись (идемпотентность).

Тесты:

- Интеграционные тесты с «time travel» (моки времени).

## AI Financial Assistant (ИИ-финансовый ассистент)

Доступ к данным:

- Только через локальный сервис, читающий Drift.
- Без прямых запросов к Firebase из ассистента.

Конфиденциальность:

- Не отдавать идентифицирующие данные пользователя.
- Аггрегированные ответы: «сколько потратил на X в этом месяце», «топ категорий расходов».

Функциональность:

- Простые вопросы: «Сколько я потратил на еду в этом месяце?», «Какие у меня самые большие расходы?»
- Ассистент не должен сам изменять данные — только читать и рекомендовать.
